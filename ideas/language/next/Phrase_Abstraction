Full Abstraction: Phrase Polymorphic Functions
==============================================
Goal: Curv should allow you to abstract over any phrase, without restriction.
Not just over expressions. Mechanisms we can provide:
 * Dynamic typing. Static type systems generally prohibit full abstraction
   over expressions, and/or enter into a complexity death-spiral attempting
   to support abstraction over more and more use cases. Why does GHC Haskell
   have over 200 mutually-incompatible language extensions? It's the complexity
   death-spiral.
 * Metaprogramming, wherein non-expression phrases are reified as values.
   You can abstract over and process these values using the full power
   of the language, then convert the values back to non-expressions.
   * Eg, an imperative statement reifies as a procedure taking an environment
     record as an argument. The ER contains mutable variable bindings.
 * Metafunctions: like macros, except they map [environment,syntax-tree]
   -> IR-tree, whereas macros map syntax-tree -> syntax-tree.
   This adheres to the parse-not-validate philosophy, has various benefits.
 * Non-expression phrases are run-time semantic entities that directly support
   abstraction. Similar to how I'm adding abstraction for locatives.
   It's possible because of Tennent's abstraction principle.
    * The IR trees for these abstractions over non-expressions can be provided
      for use with metafunctions, even if the IR doesn't have syntax (due to
      problems of syntax design).
 * Phrase-polymorphic functions, a new idea that is explored here.
   These are higher level than macros, with fewer foot-guns.
   Maybe these are powerful enough that I can omit macros from the language.

Actions, Generators, Statements: Three imperative phrase types
--------------------------------------------------------------
* The three phrase types can be statically distinguished?
* An action is legal in a generator or statement context.
* Generators and statements cannot be mixed (overturns Curv 0.5).

The proposed alternate switch phrase (a macro) uses syntax of the form
  <pattern> -> <action>
  <pattern> -> <generator>
  <pattern> -> <statement>

Since I'm giving this syntax a meaning *in the context of a switch*,
I'd like to give this syntax an independent meaning.

Actually, the meaning is clear to a human, and code that looks like this
evaluates to a function, but you can't call the resulting function, because
function calls are only legal in an expression context. So close!
* Continuing my argument by implementation, what's missing is syntax for
  calling action-functions, generator-functions and statement-functions.
  This call syntax would need to be statically classifiable by phrase type.

There's one big exception to this line of thought. A switch can contain
a statement-function that contains references to non-local mutable variables.
These are not compilable in Curv 0.5. The Object proposal suggests that these
statement-functions are in fact not values but object-refs, and the
corresponding phrase is a locative. These entities can be passed as
locative arguments to the appropriate kind of lambda entity.

So let's consider ways to legalize act/gen/state-functions and make them
first-class.
 1. AGS-lambdas are expressions. Calls to AGS-function values require
    alternative call syntax.
 2. AGS-lambdas are not expressions. Call phrases that have these
    not-expressions as arguments are themselves not expressions,
    but instead may be AGS phrases. Phrase-polymorphic functions exist
    that can map non-expressions to non-expressions. This is a model
    for what 'if' and 'switch' do. It could allow `switch` to be something more
    semantic than a macro.

#2 looks promising.

Phrase Polymorphic Functions
----------------------------
PPFs can be polymorphic across across these phrase types:
    Action, Generator, Statement, Expression, Locative.
(But not Pattern or Definition. We have metaprogramming for abstraction
over these phrases. A Schema is a reified Pattern, a Module is a reified
Definition.)

Examples of phrase-polymorphic syntax in Curv:
    if (a) b else c     -- currently polymorphic across AGSE (could be L)
    [a, b]              -- currently polymorphic across EL
    switch ...          -- proposed

Maybe I can consider these features as an IR (intermediate representation)
generated by macros. I'm not worried about syntax, but I want guarantees
that the IR is sound. Goals:
* Full abstraction over AGSEL phrases.
* AGSEL bound to a name.
* Functions with AGSEL parameters and results.
This is a metaprogramming API, working with unevaluated IR nodes.
