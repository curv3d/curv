// Copyright Doug Moen 2016-2018.
// Distributed under The MIT Licence.
// See accompanying file LICENCE.md or https://opensource.org/licenses/MIT

/* Curv standard library, automatically loaded at startup. */
{

deg = tau/360;
e = 2.71828182845904523536028747135266249775724709369995;
phi = sqrt 5 * .5 + .5;
X = 0;
Y = 1;
Z = 2;
T = 3;
X_axis = [1,0,0];
Y_axis = [0,1,0];
Z_axis = [0,0,1];
nl = decode[0xA]; // ASCII newline

ceil n = -floor(-n);
trunc n = if (n >= 0) floor(n) else ceil(n);
mod(a,m) = a - m * floor(a/m);
rem(a,m) = a - m * trunc(a/m);
lerp(a,b,t) = a*(1-t) + b*t;
// Smooth Hermite interpolation between 0 and 1 when lo < x < hi.
// Used to construct a threshold function with a smooth transition.
// Results are undefined if lo >= hi.
// https://en.wikipedia.org/wiki/Smoothstep
smoothstep(lo,hi,x) =
    let t = clamp((x - lo)/(hi - lo), 0, 1);
    in t*t*(3 - 2*t);
clamp(v,lo,hi) = min(max(v,lo),hi);
//isinf x = x == inf || x == -inf; // deprecated

tan a = sin a / cos a;
atan x = atan2(x,1);
sec a = 1 / sin a;
csc a = 1 / cos a;
cot a = cos a / sin a;

// lists
concat vv = [for (v in vv) for (i in v) i];
reverse v = v[count(v)-1..0 by -1];
map f list = [for (x in list) f x];
filter p list = [for (x in list) if (p x) x];
reduce (zero, f) list =
    if (list == [])
        zero
    else
        do  var r := list[0];
            for (i in 1..<count list)
                r := f(r, list[i]);
        in r;
sum = reduce(0, (x,y)->x+y);
product = reduce(1, (x,y)->x*y);
compose = reduce(x->x, (f,g)->x->g(f x));

merge rs = {for (r in rs) ...r};

ensure pred expr = do assert(pred expr) in expr;

// complex numbers: [RE,IM]
RE=0;
IM=1;
cmul(z,w) = [z[RE]*w[RE] - z[IM]*w[IM], z[IM]*w[RE] + z[RE]*w[IM]];
csqr(z) = [ z[RE]*z[RE] - z[IM]*z[IM], 2*z[RE]*z[IM] ];

////////////////////
// Linear Algebra //
////////////////////
is_vec2 x = is_list x && count x == 2 && is_num(x[0]) && is_num(x[1]);
is_vec3 x = is_list x && count x == 3 && is_num(x[0]) && is_num(x[1]) && is_num(x[2]);
indices a = 0..<count a;
cross(p,q) = [p[Y]*q[Z] - p[Z]*q[Y], p[Z]*q[X] - p[X]*q[Z], p[X]*q[Y] - p[Y]*q[X]];
identity(n) = [for(i in 1..n) [for(j in 1..n) if(i==j) 1 else 0]];
transpose(a) = [for (i in indices(a[0])) [for (j in indices a) a[j,i]]];
normalize v = v / mag v;

// phase angle of a vector, range tau/2 to -tau/2
phase v = atan2(v[Y],v[X]);

// convert phase angle to unit vector
cis theta = [cos theta, sin theta];

// perp: Rotate a 2D point by 90 degrees CCW. Multiply a complex number by i.
// It's the 2D analog of the 3D vector cross product (Cross in Mathematica).
// dot(perp a, b) is the "perp-dot" product:
// see: 'The Pleasures of "Perp-Dot" Products', Graphics Gems IV.
perp(x,y) = (-y, x);

// angle between two vectors. Deprecated.
//angle(a,b) = acos(dot(a,b) / (mag a * mag b));

////////////
// SHAPES //
////////////
make_shape r =
    let shape = {
            is_2d : false,
            is_3d : false,
            bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
            colour p : [.8, .8, .5]^2.2,
            ... r,
        };
        assert (shape.is_2d || shape.is_3d);
        assert (is_bbox3(shape.bbox));
        assert (is_fun(shape.colour));
        assert (defined(shape.dist) && is_fun(shape.dist));
    in shape;

is_shape x =
    defined(x.is_2d) && defined(x.is_3d) && defined(x.bbox)
    && defined(x.dist) && defined(x.colour);

size shape = shape.bbox[MAX] - shape.bbox[MIN];

MIN = 0;
MAX = 1;

is_bbox2 = match [
    (is_vec2 _, is_vec2 _) -> true;
    _ -> false;
];
is_bbox3 = match [
    (is_vec3 _, is_vec3 _) -> true;
    _ -> false;
];

/////////////////////
// CIRCULAR SHAPES //
/////////////////////

circle =
    let circle_e d =
            let r = d / 2;
            in make_shape {
                dist(x,y,z,t) = mag(x,y) - r;
                bbox = [[-r,-r,0],[r,r,0]];
                is_2d = true;
            };
    in make_shape {
        ... circle_e 2,
        call : circle_e,
    };

ellipse(dx,dy) = circle 1 >> stretch(dx,dy);

sphere =
    let sphere_e d =
            let r = d / 2;
            in make_shape {
                dist(x,y,z,t) = mag(x,y,z) - r;
                bbox = [[-r,-r,-r],[r,r,r]];
                is_3d = true;
            };
    in make_shape {
        ... sphere_e 2,
        call : sphere_e,
    };

ellipsoid(dx,dy,dz) = sphere 1 >> stretch(dx,dy,dz);

cylinder =
    {
        call = exact;
        mitred{d,h} = extrude.mitred h (circle d);
        exact{d,h} = extrude.exact h (circle d);
    };

// Cone: +Z is up, origin is in the middle of the base.
// TODO: Provide an interface capable of constructing an infinite cone.
cone =
    {
        call = exact;
        mitred{d, h: height} =
            let radius = d / 2;
            in make_shape {
                dist(x,y,z,t) =
                    let q = [mag(x,y), z];
                        tip = q - [0, height];
                        mantleDir = normalize(height, radius);
                        mantle = dot(tip, mantleDir);
                    in max(mantle, -q[Y]);
                bbox = [[-radius,-radius,0],[radius,radius,height]];
                is_3d = true
            };
        // Euclidean distance field.
        // Credit: MERCURY (http://mercury.sexy/hg_sdf)
        exact{d, h: height} =
            let radius = d / 2;
            in make_shape {
                dist(x,y,z,t) =
                    let q = [mag(x,y), z];
                        apex = q - [0, height];
                        mantleDir = normalize(height, radius);
                        mantle = dot(apex, mantleDir);
                        projected = dot(apex, [mantleDir[Y], -mantleDir[X]]);
                    in do
                        var d := max(mantle, -q[Y]);

                        // distance to apex
                        if (q[Y] > height && projected < 0)
                            d := max(d, mag(apex));

                        // distance to base ring
                        if (q[X] > radius && projected > mag(height, radius))
                            d := max(d, mag(q - [radius, 0]));
                    in d;
                bbox = [[-radius,-radius,0],[radius,radius,height]];
                is_3d = true
            };
    };

// credit: Inigo Quilez
capsule{d, from: a, to: b} =
    let ba = b - a;
        r = d / 2;
    in make_shape {
        dist p =
            let pa = p[[X,Y,Z]] - a;
                h = clamp(dot(pa,ba) / dot(ba,ba), 0, 1);
            in mag(pa - ba*h) - r;
        bbox = [min(a-r,b-r), max(a+r,b+r)];
        is_3d = true;
    };

stroke{d, from: a, to: b} =
    let r = d / 2;
        ba = b - a;
    in make_shape {
        dist p =
            let pa = p[[X,Y]] - a;
                h = clamp(dot(pa,ba) / dot(ba,ba), 0, 1);
            in mag(pa - ba*h) - r;
        bbox = [[...min(a-r,b-r),0], [...max(a+r,b+r),0]];
        is_2d = true;
    };

// d1: major diameter, from center of tube, through origin, to centre of tube.
// d2: minor diameter, of the tube.
torus {major:d1, minor:d2} = perimeter_extrude (circle d1) (circle d2);

// from OpenSCAD
revolve shape = perimeter_extrude (circle 0) shape;

// A generalized torus. Sweep a 2D shape around the perimeter of another
// 2D shape.
perimeter_extrude perimeter cross_section =
    make_shape {
        dist(x,y,z,t) = cross_section.dist( perimeter.dist(x,y,0,t), z, 0, t );
        bbox = [
            [ perimeter.bbox[MIN,X] - cross_section.bbox[MAX,X],
              perimeter.bbox[MIN,Y] - cross_section.bbox[MAX,X],
              cross_section.bbox[MIN,Y] ],
            [ perimeter.bbox[MAX,X] + cross_section.bbox[MAX,X],
              perimeter.bbox[MAX,Y] + cross_section.bbox[MAX,X],
              cross_section.bbox[MAX,Y] ],
        ];
        is_3d = true;
    };

///////////////
// POLYTOPES //
///////////////

half_space = (
    match [
    {d, normal: n} -> impl(d*n,n);
    [a, b, c] -> impl(a, normalize(cross(b-a,c-b)));
    {at: a, normal: n} -> impl(a,n);
    ]
where
    impl(a,n) = // a is point on boundary, n is unit normal
        make_shape {
            dist(x,y,z,_) = dot(-n, a-[x,y,z]);
            bbox = [ [ if (n[Y]==0 && n[Z]==0 && n[X]<0) a[X] else -inf,
                       if (n[X]==0 && n[Z]==0 && n[Y]<0) a[Y] else -inf,
                       if (n[X]==0 && n[Y]==0 && n[Z]<0) a[Z] else -inf, ],
                     [ if (n[Y]==0 && n[Z]==0 && n[X]>0) a[X] else inf,
                       if (n[X]==0 && n[Z]==0 && n[Y]>0) a[Y] else inf,
                       if (n[X]==0 && n[Y]==0 && n[Z]>0) a[Z] else inf, ] ];
            is_3d = true;
        };
);

half_plane = (
    match [
    {d, normal: n} -> impl(d*n,n);
    [a, b] -> impl(a, normalize(perp(b-a)));
    {at: a, normal: n} -> impl(a,n);
    ]
where
    impl(a,n) = // a is point on boundary, n is unit normal
        make_shape {
            dist(x,y,_,_) = dot(-n, a-[x,y]);
            bbox = [ [ if (n[Y]==0 && n[X]<0) a[X] else -inf,
                       if (n[X]==0 && n[Y]<0) a[Y] else -inf,
                       0, ],
                     [ if (n[Y]==0 && n[X]>0) a[X] else inf,
                       if (n[X]==0 && n[Y]>0) a[Y] else inf,
                       0, ], ];
            is_2d = true;
        };
);

square = (
    {
        ... square_e 2,
        call : square_e,
        circumratio : sqrt 2,
        exact : {
            ... square_e 2,
            call : square_e,
        },
        mitred : {
            ... square_m 2,
            call : square_m,
        },
    } where
        square_m d =
            let r = d / 2;
            in make_shape {
                dist(x,y,z,t) = max(abs(x,y) - r);
                bbox = [[-r,-r,0], [r,r,0]];
                is_2d = true;
            };
        square_e d = rect.exact(d,d);
);

// rect: an axis aligned rectangle.
rect = {
    call = exact;
    mitred x =
        x >> match [
        (is_vec2 b) ->
            let r = b / 2;
            in make_shape {
                dist(x,y,z,t) = max(abs(x,y) - r);
                bbox = [[-r[X],-r[Y],0],[r[X],r[Y],0]];
                is_2d = true;
            };
        (is_bbox2 b) ->
            let xmin = b[MIN,X];
                ymin = b[MIN,Y];
                xmax = b[MAX,X];
                ymax = b[MAX,Y];
            in intersection [
                if (xmin > -inf) make_shape {
                    dist(x,y,z,t) = xmin - x;
                    bbox = [[xmin, -inf, 0], [inf, inf, 0]];
                    is_2d = true;
                },
                if (ymin > -inf) make_shape {
                    dist(x,y,z,t) = ymin - y;
                    bbox = [[-inf, ymin, 0], [inf, inf, 0]];
                    is_2d = true;
                },
                if (xmax < inf) make_shape {
                    dist(x,y,z,t) = x - xmax;
                    bbox = [[-inf, -inf, 0], [xmax, inf, 0]];
                    is_2d = true;
                },
                if (ymax < inf) make_shape {
                    dist(x,y,z,t) = y - ymax;
                    bbox = [[-inf, -inf, 0], [inf, ymax, 0]];
                    is_2d = true;
                },
            ];
        {xmin=-inf, ymin=-inf, xmax=inf, ymax=inf} ->
            mitred((xmin,ymin),(xmax,ymax));
        ];
    exact x =
        x >> match [
        (is_vec2 b) ->
            let r = b / 2;
            in make_shape {
                dist(x,y,z,t) =
                    let d = abs(x,y) - r;
                    in min(max d, 0) + mag(max(d,0));
                bbox = [[-r[X],-r[Y],0],[r[X],r[Y],0]];
                is_2d = true;
            };
        (is_bbox2 b) ->
            let lo = b[MIN];
                hi = b[MAX];
                outsideness(a,amin,amax) =
                    if (a < amin) amin - a
                    else if (a > amax) a - amax
                    else 0;
            in make_shape {
                dist(x,y,z,t) =
                    let ind = max[max(lo-[x,y]), max([x,y]-hi)];
                        outd = mag(outsideness(x,lo[X],hi[X]),
                                   outsideness(y,lo[Y],hi[Y]));
                    in if (ind <= 0) ind else outd;
                bbox = [[...lo,0], [...hi,0]];
                is_2d = true;
            };
        {xmin=-inf, ymin=-inf, xmax=inf, ymax=inf} ->
            exact((xmin,ymin),(xmax,ymax));
        ];
};

// regular_polygon: n is # of sides, d is incircle diameter
regular_polygon n = (
    {
        ... mitred 2,
        call: mitred,
        mitred: mitred,
        circumratio : 1 / cos(angle/2),
    } where
        angle = tau / n;
        mitred d = half_plane{d: d/2, normal: [0,-1]}
                   >> repeat_radial n;
);

// convex polygon: vertices are in counterclockwise order.
convex_polygon = {
    call = mitred;
    mitred pts =
        intersection[
            for (i in indices pts)
                half_plane (pts[mod(i+1, count pts)], pts[i]),
            rect(min pts, max pts) // bounding box
        ];
};

// box: an axis aligned cuboid.
box = {
    call = exact;
    mitred a =
        a >> match [
        (is_vec3 b) ->
            let r = b / 2;
            in make_shape {
                dist(x,y,z,t) = max(abs(x,y,z) - r);
                bbox = [-r, r];
                is_3d = true;
            };
        (is_bbox3 b) ->
            let lo = b[MIN];
                hi = b[MAX];
            in make_shape {
                dist(x,y,z,t) = max(max(lo-[x,y,z]), max([x,y,z]-hi));
                bbox = b;
                is_3d = true;
            };
        {xmin=-inf, ymin=-inf, zmin=-inf, xmax=inf, ymax=inf, zmax=inf} ->
            mitred((xmin,ymin,zmin),(xmax,ymax,zmax));
        ];
    exact a =
        a >> match [
        (is_vec3 b) ->
            let r = b / 2;
            in make_shape {
                dist(x,y,z,t) =
                    let d = abs(x,y,z) - r;
                    in min(max d, 0) + mag(max(d,0));
                bbox = [-r, r];
                is_3d = true;
            };
        (is_bbox3 b) ->
            let lo = b[MIN];
                hi = b[MAX];
                outsideness(a,amin,amax) =
                    if (a < amin) amin - a
                    else if (a > amax) a - amax
                    else 0;
            in make_shape {
                dist(x,y,z,t) =
                    let ind = max[max(lo-[x,y,z]), max([x,y,z]-hi)];
                        outd = mag(outsideness(x,lo[X],hi[X]),
                                   outsideness(y,lo[Y],hi[Y]),
                                   outsideness(z,lo[Z],hi[Z]));
                    in if (ind <= 0) ind else outd;
                bbox = b;
                is_3d = true;
            };
        {xmin=-inf, ymin=-inf, zmin=-inf, xmax=inf, ymax=inf, zmax=inf} ->
            exact((xmin,ymin,zmin),(xmax,ymax,zmax));
        ];
};

prism n = ({
    ... prism_m {d: 2, h: 2},
    call : prism_m,
    mitred : {
        ... prism_m {d: 2, h: 2},
        call : prism_m,
    },
} where
    prism_m {d,h} = regular_polygon n .mitred d >> extrude.mitred h;
);

// TODO: pyramid(n,d,h)

tetrahedron = (
    {
        ... tetrahedron_m 2,
        call : tetrahedron_m,
        mitred : {
            ... tetrahedron_m 2,
            call : tetrahedron_m,
        },
        // radius of circumscribed sphere / radius of inscribed sphere
        circumratio : (sqrt(3/2)/2) / (1/(2*sqrt 6)),
    } where
        tetrahedron_m d =
            let r = d / 2;
                // vertices of a tetrahedron
                v1 = [1,1,1];
                v2 = [-1,-1,1];
                v3 = [1,-1,-1];
                v4 = [-1,1,-1];

                // faces: (1,2,3) (1,4,2) (2,4,3) (1,3,4)
                // vertices listed in CCW order viewed from outside (right hand rule)

                // face normals
                n1 = normalize(cross(v1-v3,v2-v3));
                n2 = normalize(cross(v1-v2,v4-v2));
                n3 = normalize(cross(v2-v3,v4-v3));
                n4 = normalize(cross(v4-v3,v1-v3));
            in make_shape {
                dist p :
                    max [
                        dot(p[[X,Y,Z]], n1),
                        dot(p[[X,Y,Z]], n2),
                        dot(p[[X,Y,Z]], n3),
                        dot(p[[X,Y,Z]], n4),
                    ] - r,
                is_3d : true,
                bbox : sqrt(3) * [[-r,-r,-r], [r,r,r]],
            };
);

cube = (
    {
        ... cube_e 2,
        call: cube_e,
        circumratio: sqrt 3,
        exact: {
            ... cube_e 2,
            call: cube_e
        },
        mitred: {
            ... cube_m 2,
            call: cube_m
        },
    }
    where
        cube_m d =
            let r = d / 2;
            in make_shape {
                dist(x,y,z,t) = max(abs(x,y,z) - r);
                bbox = [[-r, -r, -r], [r,r,r]];
                is_3d = true;
            };
        cube_e d = box.exact(d,d,d);
);

octahedron = (
    {
        ... octahedron_m 2,
        call : octahedron_m,
        circumratio : (1/2*sqrt 2) / (1/6*sqrt 6),
        mitred: {
            ... octahedron_m 2,
            call: octahedron_m
        },
    } where
        octahedron_m d =
            let r = d / 2;
                v0 = normalize(1,1,1);
                v1 = normalize(-1,1,1);
                v2 = normalize(1,-1,1);
                v3 = normalize(1,1,-1);
                // radius of circumscribed sphere / radius of inscribed sphere
                circumratio = (1/2*sqrt 2) / (1/6*sqrt 6);
            in make_shape {
                dist p :
                    max [
                        abs(dot(p[[X,Y,Z]], v0)),
                        abs(dot(p[[X,Y,Z]], v1)),
                        abs(dot(p[[X,Y,Z]], v2)),
                        abs(dot(p[[X,Y,Z]], v3)),
                    ] - r,
                is_3d : true,
                bbox : circumratio * [[-r,-r,-r], [r,r,r]],
            };
);

dodecahedron = (
    {
        ... dodecahedron_m 2,
        call : dodecahedron_m,
        circumratio : (.25*(sqrt 3 + sqrt 15)) / (1/20*sqrt(250+110*sqrt(5))),
        mitred: {
            ... dodecahedron_m 2,
            call: dodecahedron_m
        },
    } where
        dodecahedron_m d =
            let r = d / 2;
                v0 = normalize(0, phi, 1);
                v1 = normalize(0, -phi, 1);
                v2 = normalize(1, 0, phi);
                v3 = normalize(-1, 0, phi);
                v4 = normalize(phi, 1, 0);
                v5 = normalize(-phi, 1, 0);
                midratio = (.25*(3+sqrt(5))) / (1/20*sqrt(250+110*sqrt(5)));
                circumratio = (.25*(sqrt 3 + sqrt 15)) / (1/20*sqrt(250+110*sqrt(5)));
            in make_shape {
                dist p :
                    max [
                        abs(dot(p[[X,Y,Z]], v0)),
                        abs(dot(p[[X,Y,Z]], v1)),
                        abs(dot(p[[X,Y,Z]], v2)),
                        abs(dot(p[[X,Y,Z]], v3)),
                        abs(dot(p[[X,Y,Z]], v4)),
                        abs(dot(p[[X,Y,Z]], v5)),
                    ] - r,
                is_3d : true,
                bbox : midratio * [[-r,-r,-r],[r,r,r]],
            };
);

icosahedron = (
    {
        ... icosahedron_m 2,
        call : icosahedron_m,
        circumratio : (.25*sqrt(10+2*sqrt 5)) / (1/12*(3*sqrt(3)+sqrt(15))),
        mitred: {
            ... icosahedron_m 2,
            call: icosahedron_m
        },
    } where
        icosahedron_m d =
            let r = d / 2;
                v0 = normalize(1,1,1);
                v1 = normalize(-1,1,1);
                v2 = normalize(1,-1,1);
                v3 = normalize(1,1,-1);
                v4 = normalize(0, +1, phi+1);
                v5 = normalize(0, -1, phi+1);
                v6 = normalize(+phi+1, 0, 1);
                v7 = normalize(-phi-1, 0, 1);
                v8 = normalize(+1, phi+1, 0);
                v9 = normalize(-1, phi+1, 0);
                // radius of midsphere / radius of insphere
                midratio = (phi/2) / (1/12*(3*sqrt(3)+sqrt(15)));
                circumratio = (.25*sqrt(10+2*sqrt 5)) / (1/12*(3*sqrt(3)+sqrt(15)));
            in make_shape {
                dist p :
                    max [
                        abs(dot(p[[X,Y,Z]], v0)),
                        abs(dot(p[[X,Y,Z]], v1)),
                        abs(dot(p[[X,Y,Z]], v2)),
                        abs(dot(p[[X,Y,Z]], v3)),
                        abs(dot(p[[X,Y,Z]], v4)),
                        abs(dot(p[[X,Y,Z]], v5)),
                        abs(dot(p[[X,Y,Z]], v6)),
                        abs(dot(p[[X,Y,Z]], v7)),
                        abs(dot(p[[X,Y,Z]], v8)),
                        abs(dot(p[[X,Y,Z]], v9)),
                    ] - r,
                is_3d : true,
                bbox : midratio * [[-r,-r,-r], [r,r,r]],
            };
);

/////////////////////////////////////////////
// BOOLEAN / SET THEORETIC SHAPE OPERATORS //
/////////////////////////////////////////////

nothing =
    make_shape {
        dist p : inf,
        bbox : [[inf,inf,inf],[-inf,-inf,-inf]],
        is_2d : true,
        is_3d : true,
    };
everything =
    make_shape {
        dist p : -inf,
        bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
        is_2d : true,
        is_3d : true,
    };
complement s =
    make_shape {
        dist p : -s.dist p,
        bbox : [[-inf,-inf,-inf],[inf,inf,inf]],
        is_2d : s.is_2d,
        is_3d : s.is_3d,
    };

// Approximate union that produces a mitred SDF inside. Fast.
// When unioning a list of coloured shapes, we paint the shapes from first to
// last order: the last shape is painted on top of its predecessors.
union list = reduce(nothing, _union2) list;
_union2 (s1,s2) =
    make_shape {
        dist p : min(s1.dist p, s2.dist p),
        colour p :
            let d1 = s1.dist p;
                d2 = s2.dist p;
            in if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p,
        bbox : [min(s1.bbox[MIN], s2.bbox[MIN]), max(s1.bbox[MAX], s2.bbox[MAX])],
        is_2d : s1.is_2d && s2.is_2d,
        is_3d : s1.is_3d && s2.is_3d,
    };

intersection list = reduce(everything, _intersection2) list;
_intersection2 (s1,s2) =
    make_shape {
        dist p : max(s1.dist p, s2.dist p),
        colour : s1.colour,
        bbox : [max(s1.bbox[MIN], s2.bbox[MIN]), min(s1.bbox[MAX], s2.bbox[MAX])],
        is_2d : s1.is_2d && s2.is_2d,
        is_3d : s1.is_3d && s2.is_3d,
    };

difference(s1,s2) = _intersection2(s1, complement s2);
symmetric_difference shapes = difference(union shapes, intersection shapes);

row = (match [
    (is_num d) -> shapes -> row_impl(d,shapes);
    shapes -> row_impl(null, shapes);
] where
    row_impl(d,shapes) =
        let widths = [for (s in shapes) size s [X]];
            gap = if (d==null) max widths / 4 else d;
            width = sum widths + (count shapes - 1)*gap;
        in do 
            var xdelta := [];
            var x := -width / 2;
            var i := 0;
            while (i < count shapes) (
                xdelta := concat(xdelta, [x - shapes[i].bbox[MIN,X]]);
                x := x + gap + size(shapes[i])[X];
                i := i + 1;
            );
        in union[for (i in 0..<count shapes) shapes[i] >> move(xdelta[i],0,0)];
);

smooth k = {
    union (s1,s2) =
        make_shape {
            dist p : smooth_min(s1.dist p, s2.dist p, k),
            colour p :
                let d1 = s1.dist p;
                    d2 = s2.dist p;
                in if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p,
            bbox : [ min(s1.bbox[MIN], s2.bbox[MIN]),
                     max(s1.bbox[MAX], s2.bbox[MAX]) ],
            is_2d : s1.is_2d && s2.is_2d,
            is_3d : s1.is_3d && s2.is_3d,
        };

    intersection (s1,s2) =
        make_shape {
            dist p : smooth_max(s1.dist p, s2.dist p, k),
            colour : s1.colour,
            bbox : [ max(s1.bbox[MIN], s2.bbox[MIN]),
                     min(s1.bbox[MAX], s2.bbox[MAX]) ],
            is_2d : s1.is_2d && s2.is_2d,
            is_3d : s1.is_3d && s2.is_3d,
        };

    difference (s1,s2) = intersection (s1, complement s2);
};

// polynomial smooth min, from IQ
// http://www.iquilezles.org/www/articles/smin/smin.htm
smooth_min(a,b,k) =
    if (a == inf)
        // TODO: work around bug in 'max' that exists on ubuntu/nvidia GTX 1050
        // Bug is: max(-inf,x) returns NaN.
        b
    else
        let h = clamp( 0.5+0.5*(b-a)/k, 0, 1 );
        in lerp( b, a, h ) - k*h*(1.0-h);
smooth_max(a,b,k) = -smooth_min(-a,-b,k);

chamfer r = {
    union (s1,s2) =
        make_shape {
            dist p =
                let a = s1.dist p;
                    b = s2.dist p;
                in chamfer_min(a,b,r);
            colour p =
                let d1 = s1.dist p;
                    d2 = s2.dist p;
                in if (d2 <= 0 || d2 <= d1) s2.colour p else s1.colour p;
            bbox = [ min(s1.bbox[MIN], s2.bbox[MIN]),
                     max(s1.bbox[MAX], s2.bbox[MAX]) ];
            is_2d = s1.is_2d && s2.is_2d;
            is_3d = s1.is_3d && s2.is_3d;
        };

    intersection (s1,s2) =
        make_shape {
            dist p =
                let a = s1.dist p;
                    b = s2.dist p;
                in chamfer_max(a,b,r);
            colour = s1.colour;
            bbox = [ max(s1.bbox[MIN], s2.bbox[MIN]),
                     min(s1.bbox[MAX], s2.bbox[MAX]) ];
            is_2d = s1.is_2d && s2.is_2d;
            is_3d = s1.is_3d && s2.is_3d;
        };

    difference (s1,s2) = intersection (s1, complement s2);

    chamfer_min(a, b, r) =
        let e = max(r - abs(a - b), 0);
        in min(a, b) - e*.5;
    chamfer_max(a,b,k) = -chamfer_min(-a,-b,k);
};

////////////////////////////
// AFFINE TRANSFORMATIONS //
////////////////////////////

move = translate;
translate _delta shape =
    let delta = if (count _delta == 2) [_delta[X],_delta[Y],0] else _delta;
        if (shape.is_2d) assert(delta[Z] == 0);
    in make_shape {
        // TODO: dist(x,y,z,t) : shape.dist(...[x,y,z]-delta, t),
        // TODO: dist p : shape.dist(...p[[X,Y,Z]]-delta, p[T]),
        dist p : shape.dist(p[X]-delta[X], p[Y]-delta[Y], p[Z]-delta[Z], p[T]),
        colour p : shape.colour(p[X]-delta[X],p[Y]-delta[Y],p[Z]-delta[Z],p[T]),
        bbox : [shape.bbox[MIN]+delta, shape.bbox[MAX]+delta],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

// Isotropic scale operation, preserves structure of the distance field.
scale (is_num s) shape =
    make_shape {
        // TODO: dist p : shape.dist(...p[[X,Y,Z]] / s, p[T]) * s,
        dist(x,y,z,t) : shape.dist(x/s, y/s, z/s, t) * s,
        colour(x,y,z,t) : shape.colour(x/s, y/s, z/s, t),
        bbox : [s*shape.bbox[MIN], s*shape.bbox[MAX]],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

// Anisotropic scale operation, result is approximate distance field.
stretch _s shape =
    let s = if (is_num _s) [_s,1,1]
            else if (is_vec2 _s) [..._s, 1]
            else let assert(is_vec3(_s) && shape.is_3d) in _s;
    in make_shape {
        // TODO: dist p : shape.dist(...p[[X,Y,Z]] / s, p[T]) * min(s),
        dist(x,y,z,t) : shape.dist(x/s[X], y/s[Y], z/s[Z], t) * min(s),
        colour(x,y,z,t) : shape.colour(x/s[X], y/s[Y], z/s[Z], t),
        bbox : [s*shape.bbox[MIN], s*shape.bbox[MAX]],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

warp_domain_xy warp shape =
    let bv = map (warp.function) [
            [shape.bbox[MIN,X], shape.bbox[MIN,Y]],
            [shape.bbox[MAX,X], shape.bbox[MIN,Y]],
            [shape.bbox[MAX,X], shape.bbox[MAX,Y]],
            [shape.bbox[MIN,X], shape.bbox[MAX,Y]],
        ];
    in make_shape {
        dist(x,y,z,t) =
            let p = warp.inverse(x,y);
            in warp.fix_distance(x,y,shape.dist(p[X], p[Y], z, t));
        colour(x,y,z,t) =
            let p = warp.inverse(x,y);
            in shape.colour(p[X], p[Y], z, t);
        bbox = [
            [ ...min bv, shape.bbox[MIN,Z] ],
            [ ...max bv, shape.bbox[MAX,Z] ],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

// rotate angle shape -- 2D rotation around the Z axis
// rotate (angle,axis) shape -- 3D rotation around specified axis
rotate arg shape =
    arg >> match [
    (is_num a) ->
        let // 2D rotation around the Z axis
            rot2(a,p) = cmul(p, cis a);
            b = if (shape.bbox[MIN,X] == -inf || shape.bbox[MIN,Y] == -inf
                    || shape.bbox[MAX,X] == inf || shape.bbox[MAX,Y] == inf)
                [[-inf,-inf], [inf,inf]]
            else
                let bv = map (p->rot2(a,p)) [
                        [shape.bbox[MIN,X], shape.bbox[MIN,Y]],
                        [shape.bbox[MAX,X], shape.bbox[MIN,Y]],
                        [shape.bbox[MAX,X], shape.bbox[MAX,Y]],
                        [shape.bbox[MIN,X], shape.bbox[MAX,Y]],
                    ];
                in [min bv, max bv];
        in make_shape {
            dist(x,y,z,t) :
                let xy = rot2(-a,(x,y));
                in shape.dist(xy[X],xy[Y],z,t),
            colour(x,y,z,t) :
                let xy = rot2(-a,(x,y));
                in shape.colour(xy[X],xy[Y],z,t),
            bbox : [
                [ b[MIN,X], b[MIN,Y], shape.bbox[MIN,Z] ],
                [ b[MAX,X], b[MAX,Y], shape.bbox[MAX,Z] ],
            ],
            is_2d : shape.is_2d,
            is_3d : shape.is_3d,
        };
    {angle, axis: a} ->
        let axis = normalize a;
            assert(shape.is_3d);
            rot3(a,axis,p) =
                    p * cos(a)
                    - cross(axis, p) * sin(a)
                    + axis * dot(axis, p * (1 - cos a));
            b = if (shape.bbox[MIN,X] == -inf || shape.bbox[MIN,Y] == -inf
                    || shape.bbox[MIN,Z] == -inf
                    || shape.bbox[MAX,X] == inf || shape.bbox[MAX,Y] == inf
                    || shape.bbox[MAX,Z] == inf
                )
                    shape.bbox
                else
                    let bb = shape.bbox;
                        bv = map (p->rot3(-angle,axis,p)) [
                            [bb[MIN,X], bb[MIN,Y], bb[MIN,Z]],
                            [bb[MAX,X], bb[MIN,Y], bb[MIN,Z]],
                            [bb[MAX,X], bb[MAX,Y], bb[MIN,Z]],
                            [bb[MIN,X], bb[MAX,Y], bb[MIN,Z]],
                            [bb[MIN,X], bb[MIN,Y], bb[MAX,Z]],
                            [bb[MAX,X], bb[MIN,Y], bb[MAX,Z]],
                            [bb[MAX,X], bb[MAX,Y], bb[MAX,Z]],
                            [bb[MIN,X], bb[MAX,Y], bb[MAX,Z]],
                        ];
                    in [ min bv, max bv ];
        in make_shape {
            //TODO: dist p : shape.dist(...rot3(angle,axis,p[[X,Y,Z]]),p[T]),
            dist(x,y,z,t) :
                let q = rot3(angle, axis, [x,y,z]);
                in shape.dist(q[X],q[Y],q[Z],t),
            colour(x,y,z,t) :
                let q = rot3(angle, axis, [x,y,z]);
                in shape.colour(q[X],q[Y],q[Z],t),
            bbox : b,
            is_3d : true,
        };
    ];

reflect_x shape =
    make_shape {
        dist(x,y,z,t) = shape.dist(-x,y,z,t);
        colour(x,y,z,t) = shape.colour(-x,y,z,t);
        bbox = [
            [-shape.bbox[MAX,X], shape.bbox[MIN,Y], shape.bbox[MIN,Z]],
            [-shape.bbox[MIN,X], shape.bbox[MAX,Y], shape.bbox[MAX,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
reflect_y shape =
    make_shape {
        dist(x,y,z,t) = shape.dist(x,-y,z,t);
        colour(x,y,z,t) = shape.colour(x,-y,z,t);
        bbox = [
            [shape.bbox[MIN,X], -shape.bbox[MAX,Y], shape.bbox[MIN,Z]],
            [shape.bbox[MAX,X], -shape.bbox[MIN,Y], shape.bbox[MAX,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
reflect_z shape =
    do assert(is_shape shape && shape.is_3d)
    in make_shape {
        dist(x,y,z,t) = shape.dist(x,y,-z,t);
        colour(x,y,z,t) = shape.colour(x,y,-z,t);
        bbox = [
            [shape.bbox[MIN,X], shape.bbox[MIN,Y], -shape.bbox[MAX,Z]],
            [shape.bbox[MAX,X], shape.bbox[MAX,Y], -shape.bbox[MIN,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
reflect_xy shape = // reflect shape across plane X=Y
    make_shape {
        dist(x,y,z,t) = shape.dist(y,x,z,t);
        colour(x,y,z,t) = shape.colour(y,x,z,t);
        bbox = [
            [shape.bbox[MIN,Y], shape.bbox[MIN,X], shape.bbox[MIN,Z]],
            [shape.bbox[MAX,Y], shape.bbox[MAX,X], shape.bbox[MAX,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
reflect_xz shape = // reflect shape across plane X=Z
    do assert(is_shape shape && shape.is_3d)
    in make_shape {
        dist(x,y,z,t) = shape.dist(z,y,x,t);
        colour(x,y,z,t) = shape.colour(z,y,x,t);
        bbox = [
            [shape.bbox[MIN,Z], shape.bbox[MIN,Y], shape.bbox[MIN,X]],
            [shape.bbox[MAX,Z], shape.bbox[MAX,Y], shape.bbox[MAX,X]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
reflect_yz shape = // reflect shape across plane Y=Z
    do assert(is_shape shape && shape.is_3d)
    in make_shape {
        dist(x,y,z,t) = shape.dist(x,z,y,t);
        colour(x,y,z,t) = shape.colour(x,z,y,t);
        bbox = [
            [shape.bbox[MIN,X], shape.bbox[MIN,Z], shape.bbox[MIN,Y]],
            [shape.bbox[MAX,X], shape.bbox[MAX,Z], shape.bbox[MAX,Y]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

reflect normal shape =
    if (normal == X_axis) reflect_x shape
    else if (normal == Y_axis) reflect_y shape
    else if (normal == Z_axis) reflect_z shape
    else error "reflect: normal vector $(normal) is not supported";

shear_x kx shape =
    warp_domain_xy {
        function(x,y) = (x + kx*y, y);
        inverse(x,y) = (x - kx*y, y);
        fix_distance(x,y,d) = d; // TODO
    } shape;

// TODO: In `taper`, the Lipschitz compensation code seems like overkill.
local_taper_x {range:(y0,y1), scale:(kx0, kx1)} shape =
    let assert(kx0 > 0 && kx1 > 0);
        assert(y0 < y1);
    in make_shape {
        dist(x,y,z,t) =
            (if (y <= y0)
                shape.dist(x/kx0,y,z,t) * kx0
            else if (y >= y1)
                shape.dist(x/kx1,y,z,t) * kx1
            else
                let kx = lerp(kx0,kx1,(y-y0)/(y1-y0));
                in shape.dist(x/kx,y,z,t) * kx
            ) * min(kx0,kx1);
        colour(x,y,z,t) =
            if (y <= y0)
                shape.colour(x/kx0,y,z,t)
            else if (y >= y1)
                shape.colour(x/kx1,y,z,t)
            else
                let kx = lerp(kx0,kx1,(y-y0)/(y1-y0));
                in shape.colour(x/kx,y,z,t);
        bbox = shape.bbox * [[max(kx0,kx1),1,1],[max(kx0,kx1),1,1]];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };
local_taper_xy {range:(z0,z1), scale:([kx0, ky0], [kx1, ky1])} shape =
    let assert(kx0 > 0 && ky0 > 0 && kx1 > 0 && ky1 > 0);
        assert(z0 < z1);
    in make_shape {
        dist(x,y,z,t) =
            (if (z <= z0)
                shape.dist(x/kx0,y/ky0,z,t) * min(kx0,ky0)
            else if (z >= z1)
                shape.dist(x/kx1,y/ky1,z,t) * min(kx1,ky1)
            else
                let kx = lerp(kx0,kx1,(z-z0)/(z1-z0));
                    ky = lerp(ky0,ky1,(z-z0)/(z1-z0));
                in shape.dist(x/kx,y/ky,z,t) * min(kx,ky)
            ) * min(kx0,kx1,ky0,ky1);
        colour(x,y,z,t) =
            if (z <= z0)
                shape.colour(x/kx0,y/ky0,z,t)
            else if (z >= z1)
                shape.colour(x/kx1,y/ky1,z,t)
            else
                let kx = lerp(kx0,kx1,(z-z0)/(z1-z0));
                    ky = lerp(ky0,ky1,(z-z0)/(z1-z0));
                in shape.colour(x/kx,y/ky,z,t);
        bbox =
            let kx = max(kx0,kx1);
                ky = max(ky0,ky1);
            in shape.bbox * [[kx,ky,1],[kx,ky,1]];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

// Classic 'swirl' image transformation.
// From: Python skimage.transform.swirl
// http://scikit-image.org/docs/dev/auto_examples/transform/plot_swirl.html
swirl{strength, d} shape =
    let r = log 2 * d/10;
        f(x,y,z,t) =
            let m = mag(x,y);
                phi = strength * e^(-m/r) + phase(x,y);
                xy = m * cis phi;
            in [xy[X],xy[Y],z,t];
    in make_shape {
        dist p = shape.dist(f p);
        colour p = shape.colour(f p);
        bbox = shape.bbox;
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

at p t shape = shape >> move(-p) >> t >> move p;

// The slice operators convert a 3D shape to a 2D shape
// by extracting a planar cross section.
slice = slice_xy;
slice_xy shape =
    make_shape {
        dist p : shape.dist(p[X],p[Y],0,p[T]),
        colour p : shape.colour(p[X],p[Y],0,p[T]),
        bbox : [
            [shape.bbox[MIN,X],shape.bbox[MIN,Y],0],
            [shape.bbox[MAX,X],shape.bbox[MAX,Y],0],
        ],
        is_2d : true,
    };
slice_xz shape =
    make_shape {
        dist p : shape.dist(p[X],0,p[Y],p[T]),
        colour p : shape.colour(p[X],0,p[Y],p[T]),
        bbox : [
            [shape.bbox[MIN,X],shape.bbox[MIN,Z],0],
            [shape.bbox[MAX,X],shape.bbox[MAX,Z],0],
        ],
        is_2d : true,
    };
slice_yz shape =
    make_shape {
        dist p : shape.dist(0,p[X],p[Y],p[T]),
        colour p : shape.colour(0,p[X],p[Y],p[T]),
        bbox : [
            [shape.bbox[MIN,Y],shape.bbox[MIN,Z],0],
            [shape.bbox[MAX,Y],shape.bbox[MAX,Z],0],
        ],
        is_2d : true,
    };

// 'extrude' converts a 2D shape to a 3D shape, linearly extruding it along the
// positive and negative Z axis by a distance of 'h'. The result is centered
// on the XY plane with a height of 2*h. Similar to Autocad extrude and
// OpenSCAD linear_extrude.
//
// The .mitred variant is cheaper, and has a mitred distance field.
// The .exact variant is the same shape with a Euclidean distance field.
extrude = {
    call = exact;
    mitred d shape =
        let h = d / 2;
        in make_shape {
            dist p : max(abs(p[Z]) - h, shape.dist(p[X],p[Y],0,p[T])),
            colour p : shape.colour(p[X],p[Y],0,p[T]),
            bbox : [
                [shape.bbox[MIN,X],shape.bbox[MIN,Y],-h],
                [shape.bbox[MAX,X],shape.bbox[MAX,Y],+h],
            ],
            is_3d : true,
        };
    exact d shape =
        let h = d / 2;
        in make_shape {
            dist p :
                let dz = abs(p[Z]) - h;
                    dxy = shape.dist(p[X],p[Y],0,p[T]);
                in mag(max([dz,dxy],0)) + min(max(dz,dxy), 0),
            colour p : shape.colour(p[X],p[Y],0,p[T]),
            bbox : [
                [shape.bbox[MIN,X],shape.bbox[MIN,Y],-h],
                [shape.bbox[MAX,X],shape.bbox[MAX,Y],+h],
            ],
            is_3d : true,
        };
};

morph t (shape1, shape2) =
    make_shape {
        dist p : lerp(shape1.dist p, shape2.dist p, t),
        colour p : lerp(shape1.colour p, shape2.colour p, t),
        bbox : lerp(shape1.bbox, shape2.bbox, t),
        is_2d : shape1.is_2d && shape2.is_2d,
        is_3d : shape1.is_3d && shape2.is_3d,
    };

loft d (shape1, shape2) =
    let r = d / 2;
    in make_shape {
        dist(x,y,z,t) =
            max(abs z - r,
                lerp(shape1.dist(x,y,0,t), shape2.dist(x,y,0,t),
                    (clamp(z, -r, r) + r) / d));
        is_3d = true;
    };

////////////////
// REPETITION //
////////////////

repeat_x d shape =
    let r = d / 2;
    in make_shape {
        dist(x,y,z,t) : shape.dist(mod(x + r, d) - r, y, z, t),
        colour(x,y,z,t) : shape.colour(mod(x + r, d) - r, y, z, t),
        bbox : [
            [-inf, shape.bbox[MIN,Y], shape.bbox[MIN,Z]],
            [+inf, shape.bbox[MAX,Y], shape.bbox[MAX,Z]],
        ],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

repeat_xy d shape =
    let r = d / 2;
    in make_shape {
        dist(x,y,z,t) =
            shape.dist(
                mod(x + r[X], 2*r[X]) - r[X],
                mod(y + r[Y], 2*r[Y]) - r[Y],
                z, t);
        colour(x,y,z,t) =
            shape.colour(
                mod(x + r[X], 2*r[X]) - r[X],
                mod(y + r[Y], 2*r[Y]) - r[Y],
                z, t);
        bbox = [
            [-inf, -inf, shape.bbox[MIN,Z]],
            [+inf, +inf, shape.bbox[MAX,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

repeat_xyz d shape =
    let r = d / 2;
    in make_shape {
        dist (x,y,z,t) =
            shape.dist(
                mod(x + r[X], 2*r[X]) - r[X],
                mod(y + r[Y], 2*r[Y]) - r[Y],
                mod(z + r[Z], 2*r[Z]) - r[Z],
                t);
        colour (x,y,z,t) =
            shape.colour(
                mod(x + r[X], 2*r[X]) - r[X],
                mod(y + r[Y], 2*r[Y]) - r[Y],
                mod(z + r[Z], 2*r[Z]) - r[Z],
                t);
        bbox = [
            [-inf, -inf, -inf],
            [+inf, +inf, +inf],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

repeat_mirror_x shape =
    make_shape {
        dist(x,y,z,t) : shape.dist(abs x, y, z, t),
        colour(x,y,z,t) : shape.colour(abs x, y, z, t),
        bbox : [
            [-shape.bbox[MAX,X], shape.bbox[MIN,Y], shape.bbox[MIN,Z]],
            shape.bbox[MAX],
        ],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

repeat_radial reps shape =
    let angle = tau/reps;
        inradius = -shape.bbox[MIN,Y];
        circumradius = inradius / cos(angle/2);
        max_x =
            if (mod(reps,4)==0)
                inradius
            else if (mod(reps,2)==0)
                circumradius
            else
                circumradius * sin((floor(reps/4)+.5)*angle);
        ashift = tau/4 + angle/2;
        f(x,y,z,t) =
            do  var a := phase[x,y] + ashift;
                var r := mag[x,y];
                a := mod(a,angle) - ashift;
                var xy := cis(a) * r;
            in (xy[X], xy[Y], z, t);
    in make_shape {
        dist p = shape.dist(f p);
        colour p = shape.colour(f p);
        // bbox is exact for regular_polygon, approximate for general case.
        bbox = [
            [ -max_x,
              -inradius,
              shape.bbox[MIN,Z] ],
            [ max_x,
              if (mod(reps,2)==0) inradius else circumradius,
              shape.bbox[MAX,Z] ]
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

////////////
// COLOUR //
////////////

colour c shape = c >> match [
    (is_vec3 c) ->
        make_shape {
            ... shape,
            colour p : c,
        };
    (ifield, cmap) ->
        make_shape {
            ... shape,
            colour : compose(ifield, cmap),
        };
    (is_shape c) ->
        make_shape {
            ... shape,
            colour : c.colour,
        };
    (is_fun c) ->
        make_shape {
            ... shape,
            colour : c,
        };
];

show_colour c = colour c everything;

sRGB = {
    call c = c^2.2;
    hue h = HSV(h,1,1);
    grey i = call(i,i,i);
    HSV c =
        let m = abs(mod(c[0] + [1,2/3,1/3], 1) * 6 - 3);
        in call(c[2] * lerp(1, clamp(m - 1, 0, 1), c[1]));
};

red = [1, 0, 0];
orange = sRGB[1, .5, 0];
yellow = [1, 1, 0];
chartreuse = sRGB.hue(1/4);
green = [0, 1, 0];
spring_green = sRGB.hue(5/12);
cyan = [0, 1, 1];
azure = sRGB.hue(7/12);
blue = [0, 0, 1];
indigo = sRGB.hue(3/4);
magenta = [1, 0, 1];
rose = sRGB.hue(11/12);

white = [1, 1, 1];
grey = sRGB[.5,.5,.5];
black = [0, 0, 0];

texture = colour;
make_texture x = colour x everything;

i_linear d (x,_,_,_) = x/d `mod` 1;
i_radial n (x,y,_,_) = (phase(x,y)/tau-.25)*n `mod` 1;
i_concentric d (x,y,_,_) = mag(x,y)/d `mod` 1;
i_gyroid (x,y,z,t) = (cos(x)*sin(y) + cos(y)*sin(z) + cos(z)*sin(x) + 1.5)/3;
i_animate period ifield (x,y,z,t) = ifield(x,y,z,t) + t/period `mod` 1;
show_ifield ifield = make_texture(ifield, sRGB.grey);

show_cmap f = union(
    rect(4.05,1.05) >> colour grey,
    rect(4,1) >> colour ((x,_,_,_)->f((x+2)/4)));

///////////////////////////////////////////////////////////////
// RESEARCH -- shapes and operators with bad distance fields //
///////////////////////////////////////////////////////////////

// This is the infinite connected 3D volume enclosed by the gyroid surface.
// Use `shell 0` to obtain the surface itself.
// https://en.wikipedia.org/wiki/Gyroid
// Lipschitz constant == 4/3. Apply 'lipschitz 1.33' after extracting isosurfaces
gyroid =
    make_shape {
        dist(x,y,z,t) = cos(x)*sin(y) + cos(y)*sin(z) + cos(z)*sin(x);
        is_3d = true;
    };

// Twist 3D space into a helix around the Z axis.
// ``tr`` is the twist rate: angle of twist (counterclockwise)
// per unit increase along the Z axis.
// Bad distance field.
twist tr shape =
    let b = shape.bbox;
        r = max(map mag (
                [b[MIN,X], b[MIN,Y]],
                [b[MAX,X], b[MIN,Y]],
                [b[MIN,X], b[MAX,Y]],
                [b[MAX,X], b[MAX,Y]],
            ));
    in make_shape {
        dist p :
            let xy = cmul(p[[X,Y]], cis(p[Z]*-tr));
            in shape.dist(xy[X], xy[Y], p[Z], p[T]),
        colour p :
            let xy = cmul(p[[X,Y]], cis(p[Z]*-tr));
            in shape.colour(xy[X], xy[Y], p[Z], p[T]),
        bbox : [[-r,-r,b[MIN,Z]],[r,r,b[MAX,Z]]],
        is_3d : true,
    };

// Bend a 2D/3D shape upward/towards +Y, through the angle `a`,
// around a circle/cylinder of diameter `d` centred on the origin/Z axis.
// The angle defaults to `tau`/`360*deg`.
// TODO: bbox is larger than necessary.
bend {d = null, angle: a = tau} shape =
    let width = shape.bbox[MAX,X] - shape.bbox[MIN,X];
        rx = width / 2 / (a/tau);
        ry = if (d==null) width/tau else d/2;
        offset = [
            (shape.bbox[MAX,X] + shape.bbox[MIN,X]) / 2,
            shape.bbox[MAX,Y] + ry,
        ];
        f(x,y,z,t) =
            let nx = (mod(phase(x,y)/pi+1.5,2)-1)*rx+offset[X];
                ny = offset[Y] - mag(x,y);
            in (nx,ny,z,t);
        ymax = shape.bbox[MAX,Y] - shape.bbox[MIN,Y] + ry;
    in make_shape {
        dist p = shape.dist(f p);
        colour p = shape.colour(f p);
        bbox = [
            [-ymax, -ymax, shape.bbox[MIN,Z]],
            [+ymax, +ymax, shape.bbox[MAX,Z]],
        ];
        is_2d = shape.is_2d;
        is_3d = shape.is_3d;
    };

///////////////////////////
// LOW LEVEL & DEBUGGING //
///////////////////////////
distance_field shape =
    make_shape {
        dist : everything.dist,
        colour p :
            let d = shape.dist p;
                c = if (d >= 0) ceil(d)-d else floor(d)-d;
            in [max(-c,0), bit(abs(d)==inf), max(c,0)],
        is_2d : true,
    };

// Select an isosurface of the shape's distance field.
// r > 0: inflate the shape, blow it up like a balloon.
// r == 0: no effect.
// r < 0: deflate the shape.
//
// If the distance field is Euclidean, then positive r yields
// the Minkowski sum of a sphere of radius r, aka rounded offset (CAD),
// aka dilation (Mathematical Morphology).
//
// If the distance field is mitred, the result is a mitred offset (CAD).
//
// WARNING: Two shapes can have identical boundaries, but different distance
// fields, so this is sensitive to the implementation of the shape.
// Useful for debugging, to visualize a distance field.
offset r shape =
    make_shape {
        dist p : shape.dist p - r,
        colour p : shape.colour p,
        bbox : [shape.bbox[MIN]-r, shape.bbox[MAX]+r],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

// Construct a shell of thickness d,
// whose boundaries are +/- d/2 from the original surface or perimeter.
// WARNING: this is implemented using isosurfaces, so the results are dependent
// on the distance field, not just on the boundary of the shape.
shell d shape =
    let r = d / 2;
    in make_shape {
        dist p : abs(shape.dist p) - r,
        colour : shape.colour,
        bbox : [shape.bbox[MIN] - r, shape.bbox[MAX] + r],
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

pancake d shape = shape >> extrude.exact 0 >> offset (d/2);

// Super kludgy function to scale a shape's distance field,
// to compensate for a Lipschitz constant that is > 1.
// So 'k' is the Lipschitz constant.
// Try k=2 to fix a 3D shape that doesn't render properly.
lipschitz k shape =
    make_shape {
        dist p : shape.dist p / k,
        colour : shape.colour,
        bbox : shape.bbox,
        is_2d : shape.is_2d,
        is_3d : shape.is_3d,
    };

// Colour the XY plane with black where the distance field gradient <= 1 (okay)
// or with rainbow colour where it is > 1 and <= n (bad)
// or with white where it is > n (worst).
// Debug strategy: find the smallest value of n that doesn't produce white,
// and that's your Lipschitz constant. Try n=2 as an initial value.
show_gradient (j,k) shape =
    let xy = make_shape {
        dist(x,y,z,t) : abs(z),
        colour p :
            let eps = 0.01;
                d = shape.dist(p[X],p[Y],0,p[T]);
                up = shape.dist(p[X],p[Y]+eps,0,p[T]);
                down = shape.dist(p[X],p[Y]-eps,0,p[T]);
                left = shape.dist(p[X]-eps,p[Y],0,p[T]);
                right = shape.dist(p[X]+eps,p[Y],0,p[T]);
                g = max(abs(d-up),abs(d-down),abs(d-left),abs(d-right)) / eps;
            in if (g <= j)
                [0,0,0]
            else if (g > k)
                [1,1,1]
            else
                sRGB.hue((g-j)/(k-j)),
        is_2d : true,
        is_3d : true,
    } in if (shape.is_2d) xy else union(shape, xy);

show_dist shape =
    let xy = make_shape {
        dist(x,y,z,t) : abs(z),
        colour p :
            let eps = 0.01;
                d = shape.dist p;
                up = shape.dist(p[X],p[Y]+eps,0,p[T]);
                down = shape.dist(p[X],p[Y]-eps,0,p[T]);
                left = shape.dist(p[X]-eps,p[Y],0,p[T]);
                right = shape.dist(p[X]+eps,p[Y],0,p[T]);
                g = max(abs(d-up),abs(d-down),abs(d-left),abs(d-right)) / eps;
                c = if (d >= 0) ceil(d)-d else floor(d)-d;
            in if (d == d)
                if (d == inf)
                    [0,1,1]
                else if (d == -inf)
                    [0,.5,.5]^2.2
                else
                    [clamp(g-1,0,1), max(-c,0), max(c,0)]^2.2
            else
                [1,1,1],
        bbox : [[-inf,-inf,0],[inf,inf,0]],
        is_2d : true,
        is_3d : true,
    };
    in if (shape.is_2d) xy else union(shape, xy);

show_axes shape =
    let eps = .05;
    in if (shape.is_2d)
        union [
            shape,
            rect(eps, inf) >> colour green,
            rect(inf, eps) >> colour red,
        ]
    else
        union [
            shape,
            box(inf, eps, eps) >> colour red,
            box(eps, inf, eps) >> colour green,
            box(eps, eps, inf) >> colour blue,
        ];

set_bbox (is_bbox3 bbox) shape = {...shape; bbox: bbox};

show_bbox shape =
    let bb =
        if (shape.is_2d)
            rect(shape.bbox[MIN,[X,Y]],shape.bbox[MAX,[X,Y]])
        else
            box(shape.bbox[MIN],shape.bbox[MAX]);
    in union(
        bb >> colour (sRGB.grey .2),
        shape `difference` bb >> colour red,
        shape >> colour green `intersection` bb,
    );

}
